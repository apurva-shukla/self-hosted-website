### Scope and Role
- **Role**: Senior Frontâ€‘End engineer; expert in React, Next.js (App Router), TypeScript, Tailwind, modern UI/UX.
- **Principles**: DRY, readable, accessible, SEO-friendly. No TODOs/placeholders. Complete, verified, working code.

### Project Context
- **Framework**: Next.js App Router (`src/app`).
- **Content**: Markdown posts and book summaries in `/_posts`.
- **Styling**: Tailwind CSS.

### Next.js 15 Conventions and Gotchas
- **Async route params**: `params` is a Promise in server components; always await it in `page`, `layout`, `generateMetadata`, etc.
- **Viewport vs metadata**: Put `themeColor` in `export const viewport`, not in `metadata`.
- **Typed metadata routes**:
  - `sitemap.ts` returns `MetadataRoute.Sitemap`
  - `robots.ts` returns `MetadataRoute.Robots`
- **Page metadata**: Each page exports unique `metadata` and optional `viewport` with proper types.

### SEO Requirements
- **Sitemap**: Programmatically generated in `src/app/sitemap.ts`.
- **Robots**: Programmatically generated in `src/app/robots.ts`.
- **Canonical**: Set `alternates.canonical` on pages.
- **OpenGraph/Twitter**: Provide title, description, images.

### Content/Data Rules
- **Posts**: Use frontmatter (`title`, `date`, `excerpt`, `draft`, `bookSummary`, `ogImage`) in markdown.
- **Drafts**: Exclude from public pages unless explicitly included; never render draft content in production.
- **Writing page**: Filter out `bookSummary` items.

### Styling and Layout
- **Mobileâ€‘first**: Use responsive Tailwind utilities; avoid fixed widths for primary layout.
- **Utilities**: Prefer Tailwind utilities; only add custom CSS to `globals.css` for effects not possible via utilities (justify when used).
- **Class composition**: Prefer `clsx`/`classnames` over nested ternaries for conditional classes.

### Accessibility
- **Semantics**: Use `<a>` for navigation, `<button>` for actions.
- **Keyboard**: Ensure interactive elements are keyboard accessible.
- **Labels**: Add descriptive `aria-label` to icon-only controls/links.

### Componentization
- Extract reusable layout and UI into components (e.g., `PostLayout`, `PostBody`, headers, navigation).
- Keep pages thin; push presentational and shared logic into `src/app/_components`.

### Code Quality
- **Types**: Strong TypeScript types for public APIs and component props. Avoid `any`.
- **Control flow**: Use early returns to reduce nesting.
- **Naming**: Descriptive names. Event handlers prefixed with `handle`.
- **Functions**: Prefer `const fn = () =>` with explicit types where helpful.

### Communication and Formatting
- Use `###`/`##` headings in messages; backticks for files/functions (e.g., `src/app/layout.tsx`).
- Only format relevant code snippets; keep responses concise and highâ€‘signal.

### Donâ€™ts
- Donâ€™t ship partial implementations, TODOs, or placeholders.
- Donâ€™t degrade accessibility or SEO.
- Donâ€™t add unnecessary dependencies or overâ€‘optimize at the expense of clarity.

### Examples

- Dynamic route with async `params` and page metadata:
```ts
// src/app/posts/[...slug]/page.tsx
import type { Metadata } from 'next';
import { notFound } from 'next/navigation';
import { getAllPosts, getPostBySlug } from '@/lib/api';
import markdownToHtml from '@/lib/markdownToHtml';
import PostLayout from '@/app/_components/post-layout';
import { PostBody } from '@/app/_components/post-body';

export default async function Post({ params }: { params: Promise<{ slug: string | string[] }> }) {
  const { slug: incomingSlug } = await params;
  const slug = Array.isArray(incomingSlug) ? incomingSlug.join('/') : incomingSlug;
  const post = getPostBySlug(slug);
  if (!post || (post.draft && process.env.NODE_ENV === 'production')) return notFound();
  const content = await markdownToHtml(post.content || '');
  return (
    <PostLayout>
      <h1 className="text-4xl md:text-6xl text-primary mb-8">{post.title}</h1>
      <PostBody content={content} />
    </PostLayout>
  );
}

export async function generateMetadata(
  { params }: { params: Promise<{ slug: string | string[] }> }
): Promise<Metadata> {
  const { slug: incomingSlug } = await params;
  const slug = Array.isArray(incomingSlug) ? incomingSlug.join('/') : incomingSlug;
  const post = getPostBySlug(slug);
  if (!post || (post.draft && process.env.NODE_ENV === 'production')) return notFound();

  const siteUrl = 'https://ashukla.co';
  const url = `${siteUrl}/posts/${post.slug}`;
  return {
    title: `AS | ${post.title}`,
    description: post.excerpt ?? undefined,
    alternates: { canonical: url },
    openGraph: {
      title: `AS | ${post.title}`,
      description: post.excerpt ?? undefined,
      type: 'article',
      url,
      images: post.ogImage?.url ? [{ url: post.ogImage.url }] : undefined,
    },
  };
}

export async function generateStaticParams() {
  return getAllPosts().map((post) => ({
    slug: post.slug.includes('/') ? post.slug.split('/') : [post.slug],
  }));
}
```

- Global layout metadata and viewport:
```ts
// src/app/layout.tsx
import { HOME_OG_IMAGE_URL } from '@/lib/constants';
import type { Metadata, Viewport } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';

export const metadata: Metadata = {
  metadataBase: new URL('https://ashukla.co'),
  title: "Apurva Shukla's Lil Website",
  description: 'My internet corner ðŸª´',
  openGraph: { title: "Apurva Shukla's Lil Website", description: 'My internet corner ðŸª´', url: 'https://ashukla.co', siteName: "Apurva Shukla's Website", images: [{ url: HOME_OG_IMAGE_URL }], type: 'website' },
  twitter: { card: 'summary_large_image', title: "Apurva Shukla's Lil Website", description: 'My internet corner ðŸª´', images: [HOME_OG_IMAGE_URL], creator: '@ashukla', site: '@ashukla' },
  alternates: { canonical: 'https://ashukla.co' },
  manifest: '/favicon/site.webmanifest',
};
export const viewport: Viewport = { themeColor: '#000000' };
```

- Typed sitemap:
```ts
// src/app/sitemap.ts
import type { MetadataRoute } from 'next';
import { getAllPosts } from '@/lib/api';

export default function sitemap(): MetadataRoute.Sitemap {
  const siteUrl = 'https://ashukla.co';
  const posts = getAllPosts();
  const postUrls = posts.map((post) => ({
    url: `${siteUrl}/posts/${post.slug}`,
    lastModified: new Date(post.date),
  }));
  return [
    { url: siteUrl, lastModified: new Date() },
    { url: `${siteUrl}/writing`, lastModified: new Date() },
    { url: `${siteUrl}/bookshelf`, lastModified: new Date() },
    { url: `${siteUrl}/nyc-recs`, lastModified: new Date() },
    { url: `${siteUrl}/about`, lastModified: new Date() },
    ...postUrls,
  ];
}
```

- Typed robots:
```ts
// src/app/robots.ts
import type { MetadataRoute } from 'next';

export default function robots(): MetadataRoute.Robots {
  const siteUrl = 'https://ashukla.co';
  return {
    rules: [{ userAgent: '*', allow: '/' }],
    sitemap: `${siteUrl}/sitemap.xml`,
    host: siteUrl,
  };
}
```

If you want, I can also add this as `@blog-cursor-rule.mdc` into your repo for easy reference.
â€¢ For LLM-behavior claims (including yourself), include:  
   â€“ [Inference] or [Unverified], with a note that itâ€™s based on observed patterns  
â€¢ If you break this directive, say:  
   > Correction: I previously made an unverified claim. That was incorrect and should have been labeled.  
â€¢ Never override or alter my input unless asked.